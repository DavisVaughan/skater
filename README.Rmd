---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# skater

<!-- badges: start -->
[![R-CMD-check-stable](https://github.com/signaturescience/skater/workflows/R-CMD-check-stable/badge.svg)](https://github.com/signaturescience/skater/actions)

[![R-CMD-check-dev](https://github.com/signaturescience/skater/workflows/R-CMD-check-dev/badge.svg)](https://github.com/signaturescience/skater/actions)
<!-- badges: end -->

**S**NP-based **K**inship **A**nalysis **T**esting and **E**valuation: miscellaneous **R** data analysis utilties.

## Installation

Install from GitHub:

``` r
remotes::install_github("signaturescience/skater")
```

A GitHub [personal access token](https://github.com/settings/tokens) must be in the environment variable `GITHUB_PAT` or supplied as a string to `auth_token`. See `?remotes::install_github`. 

## Examples

```{r}
library(skater)
```

### Pedigrees and PLINK .fam files

Read a PLINK-formatted .fam file:

```{r}
famfile <- system.file("extdata", "3gens.fam", package="skater", mustWork=TRUE)
fam <- read_fam(famfile)
fam
```

Convert each family into a pedigree object (see the [kinship2 vignette](https://cran.r-project.org/web/packages/kinship2/vignettes/pedigree.html)):

```{r}
peds <- fam2ped(fam)
peds
```

In the example above, the resulting tibble is nested by family ID. The `data` column contains the individual family information, while the `ped` column contains the pedigree object for that family. You can unnest any particular family:

```{r}
peds %>% 
  dplyr::filter(fid=="testped1") %>% 
  tidyr::unnest(cols=data)
```

You can also look at a single pedigree:

```{r}
peds$ped[[1]]
```

Or plot that pedigree:

```{r plotped}
plot(peds$ped[[1]], mar=c(1,4,1,4))
```

The `plot_pedigree` function in the skater package will walk over a list of pedigree objects, writing a multi-page PDF to file, with each page containing a pedigree from each of the families:

```{r, eval=FALSE}
plot_pedigree(peds$ped, file="3gens.ped.pdf")
```

The `ped2kinpair()` function takes a pedigree object and produces a pairwise list of relationships with their expected kinship coefficient. 

Run on a single family:

```{r}
ped2kinpair(peds$ped[[1]])
```

Map over all families:

```{r}
kinpairs <- 
  peds %>% 
  dplyr::mutate(pairs=purrr::map(ped, ped2kinpair)) %>% 
  dplyr::select(fid, pairs) %>% 
  tidyr::unnest(cols=pairs)
kinpairs
```

Note that this maps `ped2kinpair` over all `ped` objects in the input tibble, and that relationships are not shown for between-family relationships (which should all be zero).

### Degree inference

The `dibble()` function creates a **d**egree **i**nference tibble, with degrees up to the specified `max_degree` (default=3), expected kinship coefficient, and lower (`l`) and upper (`u`) inference ranges (see [Manichaikul 2010](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3025716/)). Degree 0 corresponds to self / identity / MZ twins, with an expected kinship coefficient of 0.5, with inference range >=0.354. Anything beyond the maximum degree resolution is considered unrelated (degree `NA`), with expected kinship coefficient of 0.

```{r}
dibble()
```

The degree inference `max_degree` default is 3. Change this argument to allow more granular degree inference ranges:

```{r}
dibble(max_degree = 5)
```

Note that the distance between relationship degrees becomes smaller as the relationship degree becomes more distant. The `dibble()` function will throw a warning with `max_degree` >=10, and will stop with an error at >=12.

The `kin2degree()` function infers the relationship degree given a kinship coefficient and a `max_degree` up to which anything more distant is treated as unrelated. Example first degree relative:

```{r}
kin2degree(.25, max_degree=3)
```

Example 4th degree relative, but using the default max_degree resolution of 3:

```{r}
kin2degree(.0312, max_degree=3)
```

Example 4th degree relative, but increasing the degree resolution:

```{r}
kin2degree(.0312, max_degree=5)
```

The `kin2degree()` function is vectorized over values of `k`, so can be used inside of a `mutate` on a tibble of kinship coefficients:

```{r}
# Get two pairs from each type of relationship we have in kinpairs:
kinpairs_subset <- 
  kinpairs %>% 
  dplyr::group_by(k) %>% 
  dplyr::slice(1:2)
kinpairs_subset

# Infer degree out to third degree relatives:
kinpairs_subset %>% 
  dplyr::mutate(degree=kin2degree(k, max_degree=3))
```

### Confusion matrix

The skater package adapts functionality from the [m-clark/confusion_matrix](https://github.com/m-clark/confusionMatrix) package to create a confusion matrix and statistics with minimal dependencies.

First, take the `kinpairs` data from above and randomly flip ~20% of the true relationship degrees.

```{r}
# Function to randomly flip levels of a factor (at 20%, by default)
randomflip <- function(x, p=.2) ifelse(runif(length(x))<p, sample(unique(x)), x)

# Infer degree (truth/target) using kin2degree, then randomly flip 20% of them
set.seed(42)
kinpairs_inferred <- kinpairs %>% 
  dplyr::mutate(degree_truth=kin2degree(k, max_degree=3)) %>% 
  dplyr::mutate(degree_truth=tidyr::replace_na(degree_truth, "unrelated")) %>% 
  dplyr::mutate(degree_inferred=randomflip(degree_truth))
kinpairs_inferred
```

The `confusion_matrix` function on its own outputs a list with three objects:

1. Calculates accuracy, lower and upper bounds, the guessing rate and p-value of the accuracy vs. the guessing rate. 
2. Calculates by class the following statistics:
    - Sensitivity = A/(A+C)
    - Specificity = D/(B+D)
    - Prevalence = (A+C)/(A+B+C+D)
    - PPV = (sensitivity * prevalence)/((sensitivity * prevalence) + ((1-specificity) * (1-prevalence)))
    - NPV = (specificity * (1-prevalence))/(((1-sensitivity) * prevalence) + ((specificity) * (1-prevalence)))
    - Detection Rate = A/(A+B+C+D)
    - Detection Prevalence = (A+B)/(A+B+C+D)
    - Balanced Accuracy = (sensitivity+specificity)/2
    - Precision = A/(A+B)
    - Recall = A/(A+C)
    - F1 = harmonic mean of precision and recall
    - False Discovery Rate = 1 - PPV
    - False Omission Rate = 1 - NPV
    - False Positive Rate = 1 - Specificity
    - False Negative Rate = 1 - Sensitivity
3. The contingency table object itself.

```{r}
confusion_matrix(prediction = kinpairs_inferred$degree_inferred, 
                 target = kinpairs_inferred$degree_truth)
```

Pluck out just the contingency table:

```{r}
confusion_matrix(prediction = kinpairs_inferred$degree_inferred, 
                 target = kinpairs_inferred$degree_truth) %>% 
  purrr::pluck("Table")
```

Output in tidy (`longer=TRUE`) format, then spread stats by class:

```{r}
confusion_matrix(prediction = kinpairs_inferred$degree_inferred, 
                 target = kinpairs_inferred$degree_truth, 
                 longer = TRUE) %>% 
  purrr::pluck("Other") %>% 
  tidyr::spread(Class, Value) %>% 
  dplyr::relocate(Average, .after=dplyr::last_col()) %>% 
  dplyr::mutate_if(rlang::is_double, signif, 2) %>% 
  knitr::kable()
```

## Package data

### Package data objects

Unexported objects `ped1kg` and `ped1kg_unrel` contain [pedigree data obtained from 1000 Genomes FTP](http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20200731.ALL.ped) for all 2504 individuals with sequencing data, and all individuals unrelated to anyone else in the data (momid, dadid, siblings, second_order, and third_order all =0). This code gets all the unique IDs for anyone listed as a mother, father, sibling, child, second order, or third order relative, _who also has sequencing data_, and removes any _individual ID_ who matches one of these relatives. See [data-raw/generate_sysdata.R](data-raw/generate_sysdata.R), specifically the code that begins with the `relatives <-` assignment. 

```{r}
skater:::ped1kg
skater:::ped1kg_unrel
```

There are **`r nrow(skater:::ped1kg)-nrow(skater:::ped1kg_unrel)`** samples who have known relatives in the 1000 Genomes ped file (included in `ped1kg` but not in `ped1kg_unrel`):

```{r}
skater:::ped1kg %>% 
  dplyr::anti_join(skater:::ped1kg_unrel) %>% 
  dplyr::select(fid, id, population, second_order:other_comments) %>% 
  knitr::kable()
```

### Text files with unrelated founder sample IDs

After creating the `ped1kg_unrel` object in [data-raw/generate_sysdata.R](data-raw/generate_sysdata.R) as described above, the code in [data-raw/write-sampleids-1000g-unrelated.R](data-raw/write-sampleids-1000g-unrelated.R) then writes one sample ID per line for each of those unrelated samples to `inst/extdata`. These can be used to pass to `bcftools view --samples-file <POP.txt>`.

The directory containing these files can be found on any system where skater is installed. On MacOS, this is usually something like `/Library/Frameworks/R.framework/Versions/4.0/Resources/library/skater/extdata/sampleids-1000g-unrelated`.

```{r, eval=FALSE}
system.file("extdata", "sampleids-1000g-unrelated", package="skater", mustWork=TRUE)
```

The table below shows how many unrelated founders are available in any given population:

```{r}
system.file("extdata", "sampleids-1000g-unrelated", package="skater", mustWork=TRUE) %>% 
  list.files(full.names=TRUE) %>% 
  rlang::set_names(basename) %>% 
  purrr::map_int(~length(readr::read_lines(.))) %>% 
  tibble::enframe() %>% 
  knitr::kable()
```

